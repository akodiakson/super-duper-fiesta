<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0, viewport-fit=cover">
<title>Three Hive</title>
<style>
  *, *::before, *::after { box-sizing: border-box; margin: 0; padding: 0; }

  :root {
    --bg: #1a1a2e;
    --card: #16213e;
    --accent: #e2b714;
    --correct: #0f9b58;
    --wrong: #e74c3c;
    --tri-default: #0f3460;
    --tri-hover: #1a4a7a;
    --text: #eee;
    --muted: #8892b0;
  }

  body {
    font-family: 'Segoe UI', system-ui, -apple-system, sans-serif;
    background: var(--bg);
    color: var(--text);
    min-height: 100vh;
    display: flex;
    flex-direction: column;
    align-items: center;
    user-select: none;
    overflow-x: hidden;
    padding-left: env(safe-area-inset-left);
    padding-right: env(safe-area-inset-right);
    padding-bottom: env(safe-area-inset-bottom);
  }
  body.game-active {
    overflow-x: hidden;
    overflow-y: auto;
    overscroll-behavior: none;
  }

  header {
    text-align: center;
    padding: 1.5rem 1rem 0.5rem;
  }
  header h1 {
    font-size: 1.8rem;
    color: var(--accent);
    letter-spacing: 2px;
  }
  header p {
    color: var(--muted);
    font-size: 0.9rem;
    margin-top: 0.3rem;
  }

  /* HUD Bar */
  .hud {
    display: flex;
    gap: 2rem;
    align-items: center;
    justify-content: center;
    flex-wrap: wrap;
    padding: 0.8rem 1.5rem;
    margin: 0.5rem 0;
    background: var(--card);
    border-radius: 12px;
    min-width: 320px;
  }
  .hud-item { text-align: center; }
  .hud-item .label { font-size: 0.7rem; text-transform: uppercase; color: var(--muted); letter-spacing: 1px; }
  .hud-item .value { font-size: 1.6rem; font-weight: 700; font-variant-numeric: tabular-nums; }
  .hud-item .value.timer { color: var(--accent); }
  .hud-item .value.score { color: var(--correct); }

  /* Game area */
  .game-container {
    position: relative;
    margin: 0.5rem auto;
    touch-action: none;
  }

  .drag-overlay {
    position: absolute;
    top: 0;
    left: 0;
    width: 100%;
    height: 100%;
    pointer-events: none;
    z-index: 50;
  }
  .drag-overlay polyline {
    fill: none;
    stroke: var(--accent);
    stroke-width: 3;
    stroke-linecap: round;
    stroke-linejoin: round;
    filter: drop-shadow(0 0 6px var(--accent));
  }
  .drag-overlay polyline.chain-success {
    stroke: #7c3aed;
    stroke-width: 2.5;
    filter: drop-shadow(0 0 4px #7c3aed);
    opacity: 0.7;
  }

  .chain-sum-indicator {
    position: absolute;
    background: rgba(26,26,46,0.9);
    color: var(--accent);
    font-size: 0.8rem;
    font-weight: 700;
    padding: 2px 8px;
    border-radius: 6px;
    pointer-events: none;
    z-index: 55;
    white-space: nowrap;
  }
  .chain-sum-indicator.valid { color: var(--correct); }
  .chain-sum-indicator.invalid { color: var(--wrong); }

  /* Triangle cell */
  .tri {
    position: absolute;
    pointer-events: none;
    transition: transform 0.1s, filter 0.15s;
  }
  @media (hover: hover) {
    .tri:has(polygon:hover) { transform: scale(1.08); filter: brightness(1.2); }
  }
  .tri.disabled polygon { pointer-events: none; }

  .tri polygon {
    fill: var(--tri-default);
    stroke: #0a1a3a;
    stroke-width: 2;
    transition: fill 0.2s;
    pointer-events: fill;
    cursor: pointer;
  }
  @media (hover: hover) {
    .tri polygon:hover { fill: var(--tri-hover); }
  }

  .tri.correct polygon { fill: var(--correct); }
  .tri.wrong polygon { fill: var(--wrong); }
  .tri.reveal polygon { fill: rgba(14,155,88,0.3); stroke: var(--correct); stroke-width: 2.5; stroke-dasharray: 5 3; }
  .tri.connected polygon { fill: #7c3aed; }
  .tri.drag-source polygon { fill: var(--accent); }
  .tri.chain-member polygon { fill: #c084fc; }

  @keyframes chainPulse {
    0%, 100% { filter: brightness(1); }
    50% { filter: brightness(1.4); }
  }
  .tri.drag-target-valid polygon { animation: chainPulse 0.8s ease infinite; }

  .tri text {
    fill: #fff;
    font-weight: 700;
    font-family: 'Segoe UI', system-ui, sans-serif;
    pointer-events: none;
  }

  /* Screens */
  .screen {
    display: none;
    flex-direction: column;
    align-items: center;
    gap: 1rem;
  }
  .screen.active { display: flex; }

  .btn {
    background: var(--accent);
    color: #1a1a2e;
    border: none;
    padding: 0.75rem 2rem;
    border-radius: 8px;
    font-size: 1.05rem;
    font-weight: 700;
    cursor: pointer;
    letter-spacing: 1px;
    transition: transform 0.1s, box-shadow 0.15s;
  }
  @media (hover: hover) {
    .btn:hover { transform: translateY(-2px); box-shadow: 0 4px 16px rgba(226,183,20,0.3); }
  }
  .btn:active { transform: translateY(0); }

  .btn-small {
    padding: 0.5rem 1.2rem;
    font-size: 0.85rem;
  }

  /* Difficulty selector */
  .difficulty { display: flex; gap: 0.5rem; flex-wrap: wrap; justify-content: center; }
  .difficulty button {
    background: var(--card);
    color: var(--text);
    border: 2px solid transparent;
    padding: 0.5rem 1rem;
    border-radius: 8px;
    cursor: pointer;
    font-size: 0.85rem;
    font-weight: 600;
    transition: border-color 0.15s, background 0.15s;
  }
  @media (hover: hover) {
    .difficulty button:hover { border-color: var(--accent); }
  }
  .difficulty button.selected { border-color: var(--accent); background: rgba(226,183,20,0.15); }

  /* Results */
  .result-title { font-size: 1.6rem; font-weight: 700; }
  .result-stats { color: var(--muted); text-align: center; line-height: 1.8; }
  .result-stats span { color: var(--text); font-weight: 600; }

  /* High scores */
  .scores-panel {
    background: var(--card);
    border-radius: 12px;
    padding: 1rem 1.5rem;
    min-width: 260px;
    max-width: 340px;
  }
  .scores-panel h3 {
    text-align: center;
    font-size: 0.85rem;
    text-transform: uppercase;
    letter-spacing: 1px;
    color: var(--accent);
    margin-bottom: 0.5rem;
  }
  .scores-list { list-style: none; }
  .scores-list li {
    display: flex;
    justify-content: space-between;
    padding: 0.3rem 0;
    border-bottom: 1px solid rgba(255,255,255,0.05);
    font-size: 0.9rem;
  }
  .scores-list li .rank { color: var(--muted); width: 1.5rem; }
  .scores-list li .sname { flex: 1; }
  .scores-list li .sval { color: var(--accent); font-weight: 700; font-variant-numeric: tabular-nums; }
  .empty-scores { color: var(--muted); text-align: center; font-size: 0.85rem; padding: 0.5rem 0; }

  /* Countdown overlay */
  .countdown-overlay {
    position: fixed;
    inset: 0;
    background: rgba(26,26,46,0.85);
    display: none;
    align-items: center;
    justify-content: center;
    z-index: 100;
  }
  .countdown-overlay.active { display: flex; }
  .countdown-number {
    font-size: 6rem;
    font-weight: 900;
    color: var(--accent);
    animation: countPop 0.6s ease-out;
  }
  @keyframes countPop {
    0% { transform: scale(2); opacity: 0; }
    60% { transform: scale(0.95); opacity: 1; }
    100% { transform: scale(1); opacity: 1; }
  }

  /* Shake animation for wrong taps */
  @keyframes shake {
    0%, 100% { transform: translateX(0); }
    20% { transform: translateX(-4px); }
    40% { transform: translateX(4px); }
    60% { transform: translateX(-3px); }
    80% { transform: translateX(3px); }
  }
  .tri.wrong { animation: shake 0.35s ease; }

  /* Pulse for correct */
  @keyframes pulse {
    0% { transform: scale(1); }
    50% { transform: scale(1.12); }
    100% { transform: scale(1); }
  }
  .tri.correct { animation: pulse 0.3s ease; }

  .tri polygon,
  .btn,
  .difficulty button {
    touch-action: manipulation;
  }

  .btn {
    min-height: 44px;
    min-width: 44px;
  }
  .difficulty button {
    min-height: 44px;
    min-width: 44px;
  }

  footer {
    margin-top: auto;
    padding: 1rem;
    color: var(--muted);
    font-size: 0.75rem;
    text-align: center;
  }

  @media (max-width: 480px) {
    header {
      padding: 0.8rem 0.5rem 0.3rem;
    }
    header h1 {
      font-size: 1.4rem;
    }
    header p {
      font-size: 0.78rem;
    }
    .hud {
      gap: 1rem;
      padding: 0.5rem 0.8rem;
      min-width: unset;
      width: calc(100% - 1rem);
    }
    .hud-item .value {
      font-size: 1.3rem;
    }
    .hud-item .label {
      font-size: 0.65rem;
    }
  }
</style>
</head>
<body>

<header>
  <h1>THREE HIVE</h1>
  <p>Tap multiples of 3 — drag to chain others that sum to 3!</p>
</header>

<!-- MENU SCREEN -->
<div id="menu-screen" class="screen active">
  <div style="margin-top:1rem;">
    <p style="color:var(--muted);font-size:0.8rem;margin-bottom:0.4rem;text-align:center;">DIFFICULTY</p>
    <div class="difficulty" id="diff-selector">
      <button data-diff="easy">Easy (36 s)</button>
      <button data-diff="medium" class="selected">Medium (24 s)</button>
      <button data-diff="hard">Hard (12 s)</button>
    </div>
  </div>
  <div style="margin-top:0.5rem;">
    <p style="color:var(--muted);font-size:0.8rem;margin-bottom:0.4rem;text-align:center;">TRIANGLES</p>
    <div class="difficulty" id="tri-selector">
      <button data-tri="9">9</button>
      <button data-tri="18" class="selected">18</button>
      <button data-tri="27">27</button>
    </div>
  </div>
  <button class="btn" id="start-btn">START GAME</button>
  <div class="scores-panel" id="menu-scores"></div>
</div>

<!-- HUD (visible during game) -->
<div class="hud" id="hud" style="display:none;">
  <div class="hud-item"><div class="label">Time</div><div class="value timer" id="timer-display">10.0</div></div>
  <div class="hud-item"><div class="label">Found</div><div class="value" id="found-display">0 / 0</div></div>
  <div class="hud-item"><div class="label">Chains</div><div class="value" id="chains-display" style="color:#7c3aed;">0</div></div>
  <div class="hud-item"><div class="label">Score</div><div class="value score" id="score-display">0</div></div>
</div>

<!-- GAME AREA -->
<div class="game-container" id="game-container" style="display:none;"></div>

<!-- COUNTDOWN OVERLAY -->
<div class="countdown-overlay" id="countdown-overlay">
  <div class="countdown-number" id="countdown-number">3</div>
</div>

<!-- RESULT SCREEN -->
<div id="result-screen" class="screen">
  <div class="result-title" id="result-title"></div>
  <div class="result-stats" id="result-stats"></div>
  <div style="display:flex;gap:0.6rem;flex-wrap:wrap;justify-content:center;">
    <button class="btn" id="replay-btn">PLAY AGAIN</button>
    <button class="btn btn-small" id="menu-btn" style="background:var(--card);color:var(--text);">MENU</button>
  </div>
  <div class="scores-panel" id="result-scores"></div>
</div>

<footer>Three Hive — Divisible by Three Challenge</footer>

<script>
(() => {
  /* ── Config ─────────────────────────────────── */
  const DIFFICULTIES = {
    easy:   { time: 36, numRange: [1, 33] },
    medium: { time: 24, numRange: [1, 33] },
    hard:   { time: 12, numRange: [1, 33] },
  };

  const TRIANGLE_COUNTS = [9, 18, 27];
  let triangleCount = 18; // default

  let TRI_W = 64;   // width of each triangle cell (computed dynamically)
  let TRI_H = 56;   // height (computed dynamically)
  const BONUS_STREAK = 3; // streak length for combo bonus

  /* ── Chain scoring config ──────────────────── */
  const CHAIN_POINTS = { 2: 150, 3: 250, 4: 400 };

  /* ── State ──────────────────────────────────── */
  let difficulty = 'medium';
  let cells = [];       // { num, div3, el, row, col, picked, pairable }
  let totalDiv3 = 0;
  let foundCount = 0;
  let chainCount = 0;
  let score = 0;
  let streak = 0;
  let timeLeft = 0;
  let timerInterval = null;
  let gameActive = false;

  /* ── Drag state ────────────────────────────── */
  let dragActive = false;
  let dragChain = [];       // array of cell objects in chain
  let dragPointerId = null;
  let dragStartX = 0;
  let dragStartY = 0;
  let dragStartTime = 0;
  let dragStartCell = null;
  let lastHoveredCell = null;
  let dragOverlaySvg = null;
  let dragPolyline = null;
  let sumIndicator = null;
  let cursorX = 0;
  let cursorY = 0;

  /* ── DOM refs ───────────────────────────────── */
  const $ = id => document.getElementById(id);
  const menuScreen   = $('menu-screen');
  const resultScreen = $('result-screen');
  const hud          = $('hud');
  const gameContainer= $('game-container');
  const countdownOverlay = $('countdown-overlay');
  const countdownNumber  = $('countdown-number');
  const timerDisp    = $('timer-display');
  const foundDisp    = $('found-display');
  const chainsDisp   = $('chains-display');
  const scoreDisp    = $('score-display');

  /* ── Difficulty selector ────────────────────── */
  const diffBtns = document.querySelectorAll('#diff-selector button');
  diffBtns.forEach(btn => {
    btn.addEventListener('click', () => {
      diffBtns.forEach(b => b.classList.remove('selected'));
      btn.classList.add('selected');
      difficulty = btn.dataset.diff;
    });
  });

  /* ── High scores (localStorage) ─────────────── */
  function getScores() {
    try { return JSON.parse(localStorage.getItem('hcr_scores') || '{}'); }
    catch { return {}; }
  }
  function saveScore(diff, val) {
    const all = getScores();
    if (!all[diff]) all[diff] = [];
    all[diff].push({ score: val, date: Date.now() });
    all[diff].sort((a, b) => b.score - a.score);
    all[diff] = all[diff].slice(0, 5);
    localStorage.setItem('hcr_scores', JSON.stringify(all));
  }
  function renderScores(container, diff) {
    const all = getScores();
    const list = (all[diff] || []);
    let html = `<h3>High Scores — ${diff}</h3>`;
    if (list.length === 0) {
      html += `<p class="empty-scores">No scores yet. Be the first!</p>`;
    } else {
      html += `<ul class="scores-list">`;
      list.forEach((entry, i) => {
        html += `<li><span class="rank">${i + 1}.</span><span class="sname">${new Date(entry.date).toLocaleDateString()}</span><span class="sval">${entry.score}</span></li>`;
      });
      html += `</ul>`;
    }
    container.innerHTML = html;
  }

  /* ── Triangle SVG builder ───────────────────── */
  function makeTri(num, pointsUp) {
    const svgNS = 'http://www.w3.org/2000/svg';
    const svg = document.createElementNS(svgNS, 'svg');
    svg.setAttribute('width', TRI_W);
    svg.setAttribute('height', TRI_H);
    svg.setAttribute('viewBox', `0 0 ${TRI_W} ${TRI_H}`);
    svg.classList.add('tri');

    const poly = document.createElementNS(svgNS, 'polygon');
    const pad = 3;
    let pts;
    if (pointsUp) {
      pts = `${TRI_W / 2},${pad} ${TRI_W - pad},${TRI_H - pad} ${pad},${TRI_H - pad}`;
    } else {
      pts = `${pad},${pad} ${TRI_W - pad},${pad} ${TRI_W / 2},${TRI_H - pad}`;
    }
    poly.setAttribute('points', pts);
    svg.appendChild(poly);

    const txt = document.createElementNS(svgNS, 'text');
    txt.setAttribute('x', TRI_W / 2);
    txt.setAttribute('y', pointsUp ? TRI_H * 0.62 : TRI_H * 0.42);
    txt.setAttribute('text-anchor', 'middle');
    txt.setAttribute('dominant-baseline', 'central');
    txt.setAttribute('font-size', Math.max(10, TRI_W * 0.25) + 'px');
    txt.textContent = num;
    svg.appendChild(txt);

    return svg;
  }

  /* ── Triangle selector ────────────────────────── */
  const triBtns = document.querySelectorAll('#tri-selector button');
  triBtns.forEach(btn => {
    btn.addEventListener('click', () => {
      triBtns.forEach(b => b.classList.remove('selected'));
      btn.classList.add('selected');
      triangleCount = parseInt(btn.dataset.tri, 10);
    });
  });

  /* ── Random layout generator ────────────────── */
  function generateLayout(count) {
    const maxCols = 12;
    const maxRows = 8;
    const startR = Math.floor(maxRows / 2);
    const startC = Math.floor(maxCols / 2);

    const positions = [];
    const used = new Set();
    const key = (r, c) => `${r},${c}`;
    const frontier = [[startR, startC]];
    used.add(key(startR, startC));
    positions.push([startR, startC]);

    while (positions.length < count && frontier.length > 0) {
      const idx = Math.floor(Math.random() * frontier.length);
      const [r, c] = frontier[idx];

      const neighbors = [
        [r, c - 1], [r, c + 1], [r - 1, c], [r + 1, c]
      ].filter(([nr, nc]) =>
        nr >= 0 && nr < maxRows && nc >= 0 && nc < maxCols && !used.has(key(nr, nc))
      );

      if (neighbors.length === 0) {
        frontier.splice(idx, 1);
        continue;
      }

      const [nr, nc] = neighbors[Math.floor(Math.random() * neighbors.length)];
      used.add(key(nr, nc));
      positions.push([nr, nc]);
      frontier.push([nr, nc]);
    }

    // Normalize so top-left is (0, 0)
    const minR = Math.min(...positions.map(p => p[0]));
    const minC = Math.min(...positions.map(p => p[1]));
    return positions.map(([r, c]) => [r - minR, c - minC]);
  }

  /* ── Board generation ───────────────────────── */
  function buildBoard() {
    const cfg = DIFFICULTIES[difficulty];
    const { numRange } = cfg;
    const count = triangleCount;

    // Generate a random organic layout
    const positions = generateLayout(count);
    const maxCol = Math.max(...positions.map(p => p[1]));
    const maxRow = Math.max(...positions.map(p => p[0]));
    const cols = maxCol + 1;
    const rows = maxRow + 1;

    // Compute responsive triangle size based on available space
    // Use visualViewport when available to account for browser zoom
    const vp = window.visualViewport;
    const vpW = vp ? vp.width : window.innerWidth;
    const vpH = vp ? vp.height : window.innerHeight;

    const paddingX = 16;
    const availW = vpW - paddingX;
    const idealW = Math.floor(availW / (cols / 2 + 0.5));

    const availH = vpH - 180; // leave room for header + HUD
    const idealFromH = Math.round((availH / rows) * 64 / 56);

    TRI_W = Math.min(90, Math.max(44, Math.min(idealW, idealFromH)));
    TRI_H = Math.round(TRI_W * 56 / 64);

    gameContainer.innerHTML = '';
    cells = [];
    totalDiv3 = 0;
    foundCount = 0;
    chainCount = 0;
    score = 0;
    streak = 0;
    const pool = new Set();
    while (pool.size < count) {
      pool.add(Math.floor(Math.random() * (numRange[1] - numRange[0] + 1)) + numRange[0]);
    }
    const nums = [...pool];

    // Ensure at least 25% are divisible by 3
    const minDiv3 = Math.ceil(count * 0.25);
    let div3Count = nums.filter(n => n % 3 === 0).length;
    let idx = 0;
    while (div3Count < minDiv3 && idx < nums.length) {
      if (nums[idx] % 3 !== 0) {
        let replacement;
        do { replacement = (Math.floor(Math.random() * 11) + 1) * 3; }
        while (nums.includes(replacement));
        nums[idx] = replacement;
        div3Count++;
      }
      idx++;
    }

    // Shuffle
    for (let i = nums.length - 1; i > 0; i--) {
      const j = Math.floor(Math.random() * (i + 1));
      [nums[i], nums[j]] = [nums[j], nums[i]];
    }

    // Compute board dimensions from layout
    const boardW = (cols * TRI_W / 2) + TRI_W / 2;
    const boardH = rows * TRI_H + 10;
    gameContainer.style.width = boardW + 'px';
    gameContainer.style.height = boardH + 'px';

    // Place triangles at layout positions
    positions.forEach(([r, c], i) => {
      const pointsUp = (r + c) % 2 === 0;
      const num = nums[i];
      const div3 = num % 3 === 0;
      if (div3) totalDiv3++;

      const el = makeTri(num, pointsUp);

      const x = c * (TRI_W / 2);
      const y = r * TRI_H;
      el.style.left = x + 'px';
      el.style.top = y + 'px';

      const cell = { num, div3, el, row: r, col: c, picked: false, pairable: false };
      el._cell = cell;
      el.querySelector('polygon')._cell = cell;
      cells.push(cell);
      gameContainer.appendChild(el);
    });

    // Create SVG overlay for drag lines
    const svgNS = 'http://www.w3.org/2000/svg';
    dragOverlaySvg = document.createElementNS(svgNS, 'svg');
    dragOverlaySvg.classList.add('drag-overlay');
    dragOverlaySvg.setAttribute('width', boardW);
    dragOverlaySvg.setAttribute('height', boardH);
    gameContainer.appendChild(dragOverlaySvg);

    // Create sum indicator
    sumIndicator = document.createElement('div');
    sumIndicator.className = 'chain-sum-indicator';
    sumIndicator.style.display = 'none';
    gameContainer.appendChild(sumIndicator);

    // Mark pairable cells
    markPairableCells();

    updateHUD();
  }

  /* ── Pairable detection ─────────────────────── */
  function markPairableCells() {
    const nonDiv3 = cells.filter(c => !c.div3 && !c.picked);
    // For each non-div3 cell, check if it can form a valid chain (2-4 tiles summing to mult of 3)
    for (const cell of nonDiv3) {
      cell.pairable = false;
    }
    // Check all pairs
    for (let i = 0; i < nonDiv3.length; i++) {
      for (let j = i + 1; j < nonDiv3.length; j++) {
        if ((nonDiv3[i].num + nonDiv3[j].num) % 3 === 0) {
          nonDiv3[i].pairable = true;
          nonDiv3[j].pairable = true;
        }
        // Check triples
        for (let k = j + 1; k < nonDiv3.length; k++) {
          if ((nonDiv3[i].num + nonDiv3[j].num + nonDiv3[k].num) % 3 === 0) {
            nonDiv3[i].pairable = true;
            nonDiv3[j].pairable = true;
            nonDiv3[k].pairable = true;
          }
          // Check quads
          for (let l = k + 1; l < nonDiv3.length; l++) {
            if ((nonDiv3[i].num + nonDiv3[j].num + nonDiv3[k].num + nonDiv3[l].num) % 3 === 0) {
              nonDiv3[i].pairable = true;
              nonDiv3[j].pairable = true;
              nonDiv3[k].pairable = true;
              nonDiv3[l].pairable = true;
            }
          }
        }
      }
    }
  }

  /* ── Cell center helper ────────────────────── */
  function getCellCenter(cell) {
    const x = parseFloat(cell.el.style.left) + TRI_W / 2;
    const y = parseFloat(cell.el.style.top) + TRI_H / 2;
    return { x, y };
  }

  /* ── Cell click handler (for taps) ──────────── */
  function onCellClick(cell) {
    if (!gameActive || cell.picked) return;

    if (cell.div3) {
      cell.picked = true;
      cell.el.classList.add('disabled');
      cell.el.classList.add('correct');
      foundCount++;
      streak++;
      let pts = 100;
      if (streak >= BONUS_STREAK) pts += 50 * (streak - BONUS_STREAK + 1);
      pts += Math.round(timeLeft * 10);
      score += pts;

      if (foundCount === totalDiv3) {
        endGame(true);
        return;
      }
    } else if (cell.pairable) {
      // Non-div3 but pairable — ignore tap (no penalty)
      return;
    } else {
      cell.picked = true;
      cell.el.classList.add('disabled');
      cell.el.classList.add('wrong');
      streak = 0;
      score = Math.max(0, score - 50);
    }

    updateHUD();
  }

  /* ── Drag chain logic ──────────────────────── */
  function cellFromPoint(x, y) {
    // Temporarily hide overlay to hit-test game tiles
    if (dragOverlaySvg) dragOverlaySvg.style.display = 'none';
    if (sumIndicator) sumIndicator.style.display = 'none';
    const el = document.elementFromPoint(x, y);
    if (dragOverlaySvg) dragOverlaySvg.style.display = '';
    if (sumIndicator && dragActive) sumIndicator.style.display = '';
    if (!el) return null;
    // Check the element and its parent for _cell
    if (el._cell) return el._cell;
    if (el.parentElement && el.parentElement._cell) return el.parentElement._cell;
    return null;
  }

  function updateDragPolyline() {
    if (!dragPolyline || dragChain.length === 0) return;
    const points = dragChain.map(c => {
      const ctr = getCellCenter(c);
      return `${ctr.x},${ctr.y}`;
    });
    // Add cursor position relative to game container
    const rect = gameContainer.getBoundingClientRect();
    const cx = cursorX - rect.left;
    const cy = cursorY - rect.top;
    points.push(`${cx},${cy}`);
    dragPolyline.setAttribute('points', points.join(' '));
  }

  function updateSumIndicator() {
    if (!sumIndicator || dragChain.length === 0) return;
    const sum = dragChain.reduce((s, c) => s + c.num, 0);
    const rect = gameContainer.getBoundingClientRect();
    sumIndicator.textContent = `Sum: ${sum}${dragChain.length >= 2 ? (sum % 3 === 0 ? ' \u2713' : '') : ''}`;
    sumIndicator.className = 'chain-sum-indicator';
    if (dragChain.length >= 2) {
      sumIndicator.classList.add(sum % 3 === 0 ? 'valid' : 'invalid');
    }
    sumIndicator.style.left = (cursorX - rect.left + 15) + 'px';
    sumIndicator.style.top = (cursorY - rect.top - 25) + 'px';
    sumIndicator.style.display = '';
  }

  function startDrag(cell, e) {
    dragActive = true;
    dragChain = [cell];
    dragPointerId = e.pointerId;
    dragStartX = e.clientX;
    dragStartY = e.clientY;
    dragStartTime = Date.now();
    dragStartCell = cell;
    cursorX = e.clientX;
    cursorY = e.clientY;
    lastHoveredCell = cell;

    cell.el.classList.add('drag-source');

    // Create polyline
    const svgNS = 'http://www.w3.org/2000/svg';
    dragPolyline = document.createElementNS(svgNS, 'polyline');
    dragOverlaySvg.appendChild(dragPolyline);
    updateDragPolyline();
    sumIndicator.style.display = '';
    updateSumIndicator();
  }

  function addToChain(cell) {
    if (dragChain.includes(cell)) return;
    if (dragChain.length >= 4) return;
    if (cell.picked || cell.div3) return;

    dragChain.push(cell);
    cell.el.classList.add('chain-member');
    updateDragPolyline();
    updateSumIndicator();
  }

  function removeLastFromChain() {
    if (dragChain.length <= 1) return;
    const removed = dragChain.pop();
    removed.el.classList.remove('chain-member');
    updateDragPolyline();
    updateSumIndicator();
  }

  function endDrag() {
    if (!dragActive) return;
    dragActive = false;

    const sum = dragChain.reduce((s, c) => s + c.num, 0);
    const isValid = dragChain.length >= 2 && sum % 3 === 0;

    if (isValid) {
      // Success!
      const chainSize = dragChain.length;
      let pts = CHAIN_POINTS[chainSize] || 150;
      streak++;
      if (streak >= BONUS_STREAK) pts += 50 * (streak - BONUS_STREAK + 1);
      pts += Math.round(timeLeft * 10);
      score += pts;
      chainCount++;

      // Mark cells as connected
      dragChain.forEach(c => {
        c.picked = true;
        c.el.classList.remove('drag-source', 'chain-member');
        c.el.classList.add('connected', 'disabled');
      });

      // Leave permanent polyline
      if (dragPolyline) {
        // Remove cursor point — set final points to just cell centers
        const points = dragChain.map(c => {
          const ctr = getCellCenter(c);
          return `${ctr.x},${ctr.y}`;
        });
        dragPolyline.setAttribute('points', points.join(' '));
        dragPolyline.classList.add('chain-success');
        dragPolyline = null;
      }

      // Re-evaluate pairable after removing cells
      markPairableCells();
    } else if (dragChain.length >= 2) {
      // Failed chain attempt
      streak = 0;
      score = Math.max(0, score - 50);

      // Flash wrong on chain cells
      dragChain.forEach(c => {
        c.el.classList.remove('drag-source', 'chain-member');
        c.el.classList.add('wrong');
        setTimeout(() => c.el.classList.remove('wrong'), 400);
      });

      // Remove temp polyline
      if (dragPolyline) {
        dragPolyline.remove();
        dragPolyline = null;
      }
    } else {
      // Single cell — clean up drag visuals only
      dragChain.forEach(c => {
        c.el.classList.remove('drag-source', 'chain-member');
      });
      if (dragPolyline) {
        dragPolyline.remove();
        dragPolyline = null;
      }
    }

    // Hide sum indicator
    if (sumIndicator) sumIndicator.style.display = 'none';

    dragChain = [];
    dragStartCell = null;
    lastHoveredCell = null;
    updateHUD();
  }

  /* ── Pointer event handlers ────────────────── */
  gameContainer.addEventListener('pointerdown', (e) => {
    if (!gameActive) return;
    const cell = cellFromPoint(e.clientX, e.clientY);
    if (!cell || cell.picked) return;

    e.preventDefault();
    gameContainer.setPointerCapture(e.pointerId);

    if (cell.div3) {
      // For div3 cells, record start for tap detection
      dragStartX = e.clientX;
      dragStartY = e.clientY;
      dragStartTime = Date.now();
      dragStartCell = cell;
      dragPointerId = e.pointerId;
      dragActive = false;
    } else {
      // Non-div3: start chain drag
      startDrag(cell, e);
    }
  });

  gameContainer.addEventListener('pointermove', (e) => {
    if (!gameActive) return;
    if (dragPointerId !== e.pointerId) return;

    cursorX = e.clientX;
    cursorY = e.clientY;

    if (!dragActive && dragStartCell && dragStartCell.div3) {
      // If dragging started on a div3 cell, don't do chain logic
      return;
    }

    if (!dragActive) return;

    updateDragPolyline();
    updateSumIndicator();

    // Release capture briefly to detect element under cursor
    gameContainer.releasePointerCapture(e.pointerId);
    const cell = cellFromPoint(e.clientX, e.clientY);
    gameContainer.setPointerCapture(e.pointerId);

    if (!cell || cell.picked || cell.div3) {
      lastHoveredCell = null;
      return;
    }

    if (cell === lastHoveredCell) return;
    lastHoveredCell = cell;

    // Check if this is the second-to-last cell in chain (undo)
    if (dragChain.length >= 2 && cell === dragChain[dragChain.length - 2]) {
      removeLastFromChain();
      return;
    }

    // Add to chain if not already in it
    if (!dragChain.includes(cell)) {
      addToChain(cell);
    }
  });

  gameContainer.addEventListener('pointerup', (e) => {
    if (!gameActive) return;
    if (dragPointerId !== e.pointerId) return;

    try { gameContainer.releasePointerCapture(e.pointerId); } catch {}

    const dx = e.clientX - dragStartX;
    const dy = e.clientY - dragStartY;
    const dist = Math.sqrt(dx * dx + dy * dy);
    const duration = Date.now() - dragStartTime;

    if (dragStartCell && dragStartCell.div3 && !dragActive) {
      // Tap on div3 cell
      if (dist < 10 && duration < 300) {
        onCellClick(dragStartCell);
      }
      dragStartCell = null;
      dragPointerId = null;
      return;
    }

    if (dragActive && dragChain.length === 1 && dist < 10 && duration < 300) {
      // Short tap on non-div3 cell
      const cell = dragChain[0];
      // Clean up drag visuals
      cell.el.classList.remove('drag-source');
      if (dragPolyline) { dragPolyline.remove(); dragPolyline = null; }
      if (sumIndicator) sumIndicator.style.display = 'none';
      dragActive = false;
      dragChain = [];

      if (!cell.pairable) {
        // Non-pairable non-div3: penalize
        onCellClick(cell);
      }
      // else: pairable — ignore
      dragStartCell = null;
      dragPointerId = null;
      return;
    }

    endDrag();
    dragPointerId = null;
  });

  gameContainer.addEventListener('pointercancel', (e) => {
    if (dragPointerId === e.pointerId) {
      endDrag();
      dragPointerId = null;
    }
  });

  /* ── HUD ────────────────────────────────────── */
  function updateHUD() {
    foundDisp.textContent = `${foundCount} / ${totalDiv3}`;
    chainsDisp.textContent = chainCount;
    scoreDisp.textContent = score;
  }

  /* ── Timer ──────────────────────────────────── */
  function startTimer() {
    const cfg = DIFFICULTIES[difficulty];
    timeLeft = cfg.time;
    timerDisp.textContent = timeLeft.toFixed(1);

    timerInterval = setInterval(() => {
      timeLeft -= 0.1;
      if (timeLeft <= 0) {
        timeLeft = 0;
        timerDisp.textContent = '0.0';
        endGame(false);
        return;
      }
      timerDisp.textContent = timeLeft.toFixed(1);
      // Color warning
      if (timeLeft <= 3) timerDisp.style.color = 'var(--wrong)';
      else timerDisp.style.color = '';
    }, 100);
  }

  /* ── Countdown ──────────────────────────────── */
  function doCountdown(cb) {
    let count = 3;
    countdownOverlay.classList.add('active');
    countdownNumber.textContent = count;

    const tick = () => {
      count--;
      if (count === 0) {
        countdownNumber.textContent = 'GO!';
        setTimeout(() => {
          countdownOverlay.classList.remove('active');
          cb();
        }, 400);
      } else {
        countdownNumber.textContent = count;
        // Re-trigger animation
        countdownNumber.style.animation = 'none';
        void countdownNumber.offsetHeight;
        countdownNumber.style.animation = '';
        setTimeout(tick, 600);
      }
    };
    setTimeout(tick, 600);
  }

  /* ── Game lifecycle ─────────────────────────── */
  function startGame() {
    menuScreen.classList.remove('active');
    resultScreen.classList.remove('active');
    document.body.classList.add('game-active');

    buildBoard();
    hud.style.display = 'flex';
    gameContainer.style.display = 'block';

    // Disable clicks during countdown
    gameActive = false;

    doCountdown(() => {
      gameActive = true;
      startTimer();
    });
  }

  function endGame(allFound) {
    gameActive = false;
    clearInterval(timerInterval);

    // Cancel any active drag
    if (dragActive) {
      dragChain.forEach(c => c.el.classList.remove('drag-source', 'chain-member'));
      if (dragPolyline) { dragPolyline.remove(); dragPolyline = null; }
      if (sumIndicator) sumIndicator.style.display = 'none';
      dragActive = false;
      dragChain = [];
      dragPointerId = null;
    }

    // Reveal unfound div3 cells
    cells.forEach(c => {
      if (c.div3 && !c.picked) c.el.classList.add('reveal');
      c.el.classList.add('disabled');
    });

    // Bonus for finding all
    if (allFound) {
      score += Math.round(timeLeft * 100); // big time bonus
    }
    updateHUD();

    saveScore(difficulty, score);

    // Show result after a short delay so player sees the reveal
    setTimeout(() => {
      document.body.classList.remove('game-active');
      hud.style.display = 'none';
      gameContainer.style.display = 'none';

      const pct = totalDiv3 > 0 ? Math.round((foundCount / totalDiv3) * 100) : 0;
      let title;
      if (allFound) title = 'PERFECT!';
      else if (pct >= 75) title = 'GREAT JOB!';
      else if (pct >= 50) title = 'NOT BAD!';
      else title = 'KEEP TRYING!';

      $('result-title').textContent = title;
      $('result-title').style.color = allFound ? 'var(--correct)' : (pct >= 50 ? 'var(--accent)' : 'var(--wrong)');

      $('result-stats').innerHTML = `
        Found <span>${foundCount}</span> of <span>${totalDiv3}</span> divisible-by-3 numbers<br>
        ${chainCount > 0 ? `Chains: <span style="color:#7c3aed">${chainCount}</span><br>` : ''}
        Final Score: <span style="color:var(--correct)">${score}</span><br>
        Difficulty: <span>${difficulty}</span>
        ${allFound ? `<br>Time remaining bonus: <span>+${Math.round(timeLeft * 100)}</span>` : ''}
      `;

      renderScores($('result-scores'), difficulty);
      resultScreen.classList.add('active');
    }, 1200);
  }

  /* ── Button wiring ──────────────────────────── */
  $('start-btn').addEventListener('click', startGame);
  $('replay-btn').addEventListener('click', startGame);
  $('menu-btn').addEventListener('click', () => {
    resultScreen.classList.remove('active');
    hud.style.display = 'none';
    gameContainer.style.display = 'none';
    renderScores($('menu-scores'), difficulty);
    menuScreen.classList.add('active');
  });

  /* ── Init ───────────────────────────────────── */
  renderScores($('menu-scores'), difficulty);
  // Update scores panel when difficulty changes
  diffBtns.forEach(btn => {
    btn.addEventListener('click', () => renderScores($('menu-scores'), btn.dataset.diff));
  });

})();
</script>
</body>
</html>
