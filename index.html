<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0, viewport-fit=cover">
<title>Three Hive</title>
<style>
  *, *::before, *::after { box-sizing: border-box; margin: 0; padding: 0; }

  :root {
    --bg: #1e1e2e;
    --card: #2a2a3d;
    --accent: #f59e0b;
    --accent-glow: rgba(245, 158, 11, 0.3);
    --correct: #34d399;
    --wrong: #f87171;
    --tile-default: #334155;
    --tile-hover: #475569;
    --connected: #818cf8;
    --chain-member: #a5b4fc;
    --text: #f1f5f9;
    --muted: #94a3b8;
    --stroke: #1e293b;
  }

  body {
    font-family: 'Segoe UI', system-ui, -apple-system, sans-serif;
    background: var(--bg);
    color: var(--text);
    min-height: 100vh;
    display: flex;
    flex-direction: column;
    align-items: center;
    user-select: none;
    overflow-x: hidden;
    padding-left: env(safe-area-inset-left);
    padding-right: env(safe-area-inset-right);
    padding-bottom: env(safe-area-inset-bottom);
  }
  body.game-active {
    overflow-x: hidden;
    overflow-y: auto;
    overscroll-behavior: none;
  }

  header {
    text-align: center;
    padding: 1.5rem 1rem 0.5rem;
  }
  header h1 {
    font-size: 1.8rem;
    color: var(--accent);
    letter-spacing: 2px;
  }
  header p {
    color: var(--muted);
    font-size: 0.9rem;
    margin-top: 0.3rem;
  }

  /* HUD Bar */
  .hud {
    display: flex;
    gap: 1.5rem;
    align-items: center;
    justify-content: center;
    flex-wrap: wrap;
    padding: 0.8rem 1.5rem;
    margin: 0.5rem 0;
    background: var(--card);
    border-radius: 12px;
    min-width: 320px;
  }
  .hud-item { text-align: center; }
  .hud-item .label { font-size: 0.7rem; text-transform: uppercase; color: var(--muted); letter-spacing: 1px; }
  .hud-item .value { font-size: 1.6rem; font-weight: 700; font-variant-numeric: tabular-nums; }
  .hud-item .value.timer { color: var(--accent); }
  .hud-item .value.score { color: var(--correct); }

  .buzz-badge {
    display: none;
    align-items: center;
    gap: 0.3rem;
    background: linear-gradient(135deg, #d97706, var(--accent));
    color: var(--bg);
    font-size: 0.75rem;
    font-weight: 800;
    padding: 3px 10px;
    border-radius: 20px;
    animation: pulseGlow 1.5s ease infinite;
  }
  .buzz-badge.active { display: inline-flex; }
  @keyframes pulseGlow {
    0%, 100% { box-shadow: 0 0 8px var(--accent-glow); }
    50% { box-shadow: 0 0 20px var(--accent-glow), 0 0 40px rgba(245,158,11,0.15); }
  }

  /* Game area */
  .game-container {
    position: relative;
    margin: 0.5rem auto;
    touch-action: none;
  }

  .drag-overlay {
    position: absolute;
    top: 0; left: 0;
    width: 100%; height: 100%;
    pointer-events: none;
    z-index: 50;
  }
  .drag-overlay polyline {
    fill: none;
    stroke: var(--accent);
    stroke-width: 3;
    stroke-linecap: round;
    stroke-linejoin: round;
    filter: drop-shadow(0 0 6px var(--accent));
  }
  .drag-overlay polyline.chain-success {
    stroke: var(--connected);
    stroke-width: 2.5;
    filter: drop-shadow(0 0 4px var(--connected));
    opacity: 0.7;
  }

  .chain-sum-indicator {
    position: absolute;
    background: rgba(30,30,46,0.9);
    color: var(--accent);
    font-size: 0.8rem;
    font-weight: 700;
    padding: 2px 8px;
    border-radius: 6px;
    pointer-events: none;
    z-index: 55;
    white-space: nowrap;
  }
  .chain-sum-indicator.valid { color: var(--correct); }
  .chain-sum-indicator.invalid { color: var(--wrong); }

  /* Tile cell (shared for hex and tri) */
  .cell {
    position: absolute;
    pointer-events: none;
    transition: transform 0.1s, filter 0.15s;
  }
  @media (hover: hover) {
    .cell:has(polygon:hover) { transform: scale(1.08); filter: brightness(1.2); }
  }
  .cell.disabled polygon { pointer-events: none; }

  .cell polygon {
    fill: var(--tile-default);
    stroke: var(--stroke);
    stroke-width: 2;
    transition: fill 0.2s;
    pointer-events: fill;
    cursor: pointer;
  }
  @media (hover: hover) {
    .cell polygon:hover { fill: var(--tile-hover); }
  }

  .cell.correct polygon { fill: var(--correct); }
  .cell.wrong polygon { fill: var(--wrong); }
  .cell.reveal polygon { fill: rgba(52,211,153,0.25); stroke: var(--correct); stroke-width: 2.5; stroke-dasharray: 5 3; }
  .cell.connected polygon { fill: var(--connected); }
  .cell.drag-source polygon { fill: var(--accent); }
  .cell.chain-member polygon { fill: var(--chain-member); }

  @keyframes chainPulse {
    0%, 100% { filter: brightness(1); }
    50% { filter: brightness(1.4); }
  }
  .cell.drag-target-valid polygon { animation: chainPulse 0.8s ease infinite; }

  .cell text {
    fill: #fff;
    font-weight: 700;
    font-family: 'Segoe UI', system-ui, sans-serif;
    pointer-events: none;
  }

  /* Floating feedback text */
  .float-text {
    position: absolute;
    font-weight: 800;
    font-size: 0.85rem;
    pointer-events: none;
    z-index: 60;
    animation: floatUp 0.8s ease-out forwards;
    white-space: nowrap;
  }
  @keyframes floatUp {
    0% { opacity: 1; transform: translateY(0) scale(1); }
    100% { opacity: 0; transform: translateY(-30px) scale(1.1); }
  }

  /* Screens */
  .screen {
    display: none;
    flex-direction: column;
    align-items: center;
    gap: 1rem;
  }
  .screen.active { display: flex; }

  .btn {
    background: var(--accent);
    color: var(--bg);
    border: none;
    padding: 0.75rem 2rem;
    border-radius: 8px;
    font-size: 1.05rem;
    font-weight: 700;
    cursor: pointer;
    letter-spacing: 1px;
    transition: transform 0.1s, box-shadow 0.15s;
    font-family: inherit;
  }
  @media (hover: hover) {
    .btn:hover { transform: translateY(-2px); box-shadow: 0 4px 16px var(--accent-glow); }
  }
  .btn:active { transform: translateY(0); }

  .btn-small {
    padding: 0.5rem 1.2rem;
    font-size: 0.85rem;
  }

  /* Selector buttons */
  .selector { display: flex; gap: 0.5rem; flex-wrap: wrap; justify-content: center; }
  .selector button {
    background: var(--card);
    color: var(--text);
    border: 2px solid transparent;
    padding: 0.5rem 1rem;
    border-radius: 8px;
    cursor: pointer;
    font-size: 0.85rem;
    font-weight: 600;
    font-family: inherit;
    transition: border-color 0.15s, background 0.15s;
  }
  @media (hover: hover) {
    .selector button:hover { border-color: var(--accent); }
  }
  .selector button.selected { border-color: var(--accent); background: var(--accent-glow); }

  /* Results */
  .result-title { font-size: 1.6rem; font-weight: 700; }
  .result-stats { color: var(--muted); text-align: center; line-height: 1.8; }
  .result-stats span { color: var(--text); font-weight: 600; }

  /* High scores */
  .scores-panel {
    background: var(--card);
    border-radius: 12px;
    padding: 1rem 1.5rem;
    min-width: 260px;
    max-width: 340px;
  }
  .scores-panel h3 {
    text-align: center;
    font-size: 0.85rem;
    text-transform: uppercase;
    letter-spacing: 1px;
    color: var(--accent);
    margin-bottom: 0.5rem;
  }
  .scores-list { list-style: none; }
  .scores-list li {
    display: flex;
    justify-content: space-between;
    padding: 0.3rem 0;
    border-bottom: 1px solid rgba(255,255,255,0.05);
    font-size: 0.9rem;
  }
  .scores-list li .rank { color: var(--muted); width: 1.5rem; }
  .scores-list li .sname { flex: 1; }
  .scores-list li .sval { color: var(--accent); font-weight: 700; font-variant-numeric: tabular-nums; }
  .empty-scores { color: var(--muted); text-align: center; font-size: 0.85rem; padding: 0.5rem 0; }

  /* Countdown overlay */
  .countdown-overlay {
    position: fixed;
    inset: 0;
    background: rgba(30,30,46,0.85);
    display: none;
    align-items: center;
    justify-content: center;
    z-index: 100;
  }
  .countdown-overlay.active { display: flex; }
  .countdown-number {
    font-size: 6rem;
    font-weight: 900;
    color: var(--accent);
    animation: countPop 0.6s ease-out;
  }
  @keyframes countPop {
    0% { transform: scale(2); opacity: 0; }
    60% { transform: scale(0.95); opacity: 1; }
    100% { transform: scale(1); opacity: 1; }
  }

  /* Shake animation for wrong taps (sting!) */
  @keyframes shake {
    0%, 100% { transform: translateX(0); }
    20% { transform: translateX(-4px); }
    40% { transform: translateX(4px); }
    60% { transform: translateX(-3px); }
    80% { transform: translateX(3px); }
  }
  .cell.wrong { animation: shake 0.35s ease; }

  /* Pulse for correct (pollinated!) */
  @keyframes pulse {
    0% { transform: scale(1); }
    50% { transform: scale(1.12); }
    100% { transform: scale(1); }
  }
  .cell.correct { animation: pulse 0.3s ease; }

  .cell polygon,
  .btn,
  .selector button {
    touch-action: manipulation;
  }

  .btn {
    min-height: 44px;
    min-width: 44px;
  }
  .selector button {
    min-height: 44px;
    min-width: 44px;
  }

  footer {
    margin-top: auto;
    padding: 1rem;
    color: var(--muted);
    font-size: 0.75rem;
    text-align: center;
  }

  .menu-label {
    color: var(--muted);
    font-size: 0.8rem;
    margin-bottom: 0.4rem;
    text-align: center;
    text-transform: uppercase;
    letter-spacing: 1px;
  }

  @media (max-width: 480px) {
    header {
      padding: 0.8rem 0.5rem 0.3rem;
    }
    header h1 {
      font-size: 1.4rem;
    }
    header p {
      font-size: 0.78rem;
    }
    .hud {
      gap: 1rem;
      padding: 0.5rem 0.8rem;
      min-width: unset;
      width: calc(100% - 1rem);
    }
    .hud-item .value {
      font-size: 1.3rem;
    }
    .hud-item .label {
      font-size: 0.65rem;
    }
  }
</style>
</head>
<body>

<header>
  <h1>üçØ THREE HIVE üêù</h1>
  <p>Tap multiples of 3 ‚Äî swarm the rest!</p>
</header>

<!-- MENU SCREEN -->
<div id="menu-screen" class="screen active">
  <div style="margin-top:1rem;">
    <p class="menu-label">Tile Shape</p>
    <div class="selector" id="shape-selector">
      <button data-shape="hex" class="selected">‚¨° Hexagons</button>
      <button data-shape="tri">‚ñ≥ Triangles</button>
    </div>
  </div>
  <div style="margin-top:0.5rem;">
    <p class="menu-label">Difficulty</p>
    <div class="selector" id="diff-selector">
      <button data-diff="easy">Easy (36 s)</button>
      <button data-diff="medium" class="selected">Medium (24 s)</button>
      <button data-diff="hard">Hard (12 s)</button>
    </div>
  </div>
  <div style="margin-top:0.5rem;">
    <p class="menu-label">Cells</p>
    <div class="selector" id="count-selector">
      <button data-count="9">9</button>
      <button data-count="18" class="selected">18</button>
      <button data-count="27">27</button>
    </div>
  </div>
  <button class="btn" id="start-btn">üêù START BUZZING</button>
  <div class="scores-panel" id="menu-scores"></div>
</div>

<!-- HUD (visible during game) -->
<div class="hud" id="hud" style="display:none;">
  <div class="hud-item"><div class="label">‚è± Time</div><div class="value timer" id="timer-display">10.0</div></div>
  <div class="hud-item"><div class="label">üå∏ Found</div><div class="value" id="found-display">0 / 0</div></div>
  <div class="hud-item"><div class="label">üîó Swarms</div><div class="value" id="chains-display" style="color:var(--connected);">0</div></div>
  <div class="hud-item"><div class="label">üçØ Honey</div><div class="value score" id="score-display">0</div></div>
  <div class="hud-item"><div class="buzz-badge" id="buzz-badge">üêù x0</div></div>
</div>

<!-- GAME AREA -->
<div class="game-container" id="game-container" style="display:none;"></div>

<!-- COUNTDOWN OVERLAY -->
<div class="countdown-overlay" id="countdown-overlay">
  <div class="countdown-number" id="countdown-number">3</div>
</div>

<!-- RESULT SCREEN -->
<div id="result-screen" class="screen">
  <div class="result-title" id="result-title"></div>
  <div class="result-stats" id="result-stats"></div>
  <div style="display:flex;gap:0.6rem;flex-wrap:wrap;justify-content:center;">
    <button class="btn" id="replay-btn">üêù BUZZ AGAIN</button>
    <button class="btn btn-small" id="menu-btn" style="background:var(--card);color:var(--text);">MENU</button>
  </div>
  <div class="scores-panel" id="result-scores"></div>
</div>

<footer>üçØ Three Hive ‚Äî Buzz through the numbers!</footer>

<script>
(() => {
  /* ‚îÄ‚îÄ Config ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ */
  const DIFFICULTIES = {
    easy:   { time: 36, numRange: [1, 33] },
    medium: { time: 24, numRange: [1, 33] },
    hard:   { time: 12, numRange: [1, 33] },
  };

  const BONUS_STREAK = 3;
  const CHAIN_POINTS = { 2: 150, 3: 250, 4: 400 };

  /* ‚îÄ‚îÄ State ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ */
  let difficulty = 'medium';
  let tileShape = 'hex';   // 'hex' or 'tri'
  let cellCount = 18;
  let cells = [];       // { num, div3, el, row, col, picked, pairable }
  let totalDiv3 = 0;
  let foundCount = 0;
  let chainCount = 0;
  let bestStreak = 0;
  let score = 0;
  let streak = 0;
  let timeLeft = 0;
  let timerInterval = null;
  let gameActive = false;

  // Tile sizing (computed per game)
  let TILE_W = 64;
  let TILE_H = 56;

  /* ‚îÄ‚îÄ Drag state ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ */
  let dragActive = false;
  let dragChain = [];
  let dragPointerId = null;
  let dragStartX = 0;
  let dragStartY = 0;
  let dragStartTime = 0;
  let dragStartCell = null;
  let lastHoveredCell = null;
  let dragOverlaySvg = null;
  let dragPolyline = null;
  let sumIndicator = null;
  let cursorX = 0;
  let cursorY = 0;

  /* ‚îÄ‚îÄ DOM refs ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ */
  const $ = id => document.getElementById(id);
  const menuScreen   = $('menu-screen');
  const resultScreen = $('result-screen');
  const hud          = $('hud');
  const gameContainer= $('game-container');
  const countdownOverlay = $('countdown-overlay');
  const countdownNumber  = $('countdown-number');
  const timerDisp    = $('timer-display');
  const foundDisp    = $('found-display');
  const chainsDisp   = $('chains-display');
  const scoreDisp    = $('score-display');
  const buzzBadge    = $('buzz-badge');

  /* ‚îÄ‚îÄ Selectors ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ */
  function wireSelector(id, cb) {
    const btns = document.querySelectorAll(`#${id} button`);
    btns.forEach(btn => {
      btn.addEventListener('click', () => {
        btns.forEach(b => b.classList.remove('selected'));
        btn.classList.add('selected');
        cb(btn);
      });
    });
    return btns;
  }

  const diffBtns = wireSelector('diff-selector', btn => { difficulty = btn.dataset.diff; });
  wireSelector('shape-selector', btn => { tileShape = btn.dataset.shape; });
  wireSelector('count-selector', btn => { cellCount = parseInt(btn.dataset.count, 10); });

  /* ‚îÄ‚îÄ High scores (localStorage) ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ */
  function getScores() {
    try { return JSON.parse(localStorage.getItem('hcr_scores') || '{}'); }
    catch { return {}; }
  }
  function saveScore(diff, val) {
    const all = getScores();
    if (!all[diff]) all[diff] = [];
    all[diff].push({ score: val, date: Date.now() });
    all[diff].sort((a, b) => b.score - a.score);
    all[diff] = all[diff].slice(0, 5);
    localStorage.setItem('hcr_scores', JSON.stringify(all));
  }
  function renderScores(container, diff) {
    const all = getScores();
    const list = (all[diff] || []);
    let html = `<h3>üçØ High Scores ‚Äî ${diff}</h3>`;
    if (list.length === 0) {
      html += `<p class="empty-scores">No honey yet. Start buzzing!</p>`;
    } else {
      html += `<ul class="scores-list">`;
      list.forEach((entry, i) => {
        html += `<li><span class="rank">${i + 1}.</span><span class="sname">${new Date(entry.date).toLocaleDateString()}</span><span class="sval">${entry.score} üçØ</span></li>`;
      });
      html += `</ul>`;
    }
    container.innerHTML = html;
  }

  /* ‚îÄ‚îÄ SVG cell builders ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ */
  function makeTriSvg(num, pointsUp) {
    const svgNS = 'http://www.w3.org/2000/svg';
    const svg = document.createElementNS(svgNS, 'svg');
    svg.setAttribute('width', TILE_W);
    svg.setAttribute('height', TILE_H);
    svg.setAttribute('viewBox', `0 0 ${TILE_W} ${TILE_H}`);
    svg.classList.add('cell');

    const poly = document.createElementNS(svgNS, 'polygon');
    const pad = 3;
    let pts;
    if (pointsUp) {
      pts = `${TILE_W / 2},${pad} ${TILE_W - pad},${TILE_H - pad} ${pad},${TILE_H - pad}`;
    } else {
      pts = `${pad},${pad} ${TILE_W - pad},${pad} ${TILE_W / 2},${TILE_H - pad}`;
    }
    poly.setAttribute('points', pts);
    svg.appendChild(poly);

    const txt = document.createElementNS(svgNS, 'text');
    txt.setAttribute('x', TILE_W / 2);
    txt.setAttribute('y', pointsUp ? TILE_H * 0.62 : TILE_H * 0.42);
    txt.setAttribute('text-anchor', 'middle');
    txt.setAttribute('dominant-baseline', 'central');
    txt.setAttribute('font-size', Math.max(10, TILE_W * 0.25) + 'px');
    txt.textContent = num;
    svg.appendChild(txt);

    return svg;
  }

  function makeHexSvg(num, radius) {
    const svgNS = 'http://www.w3.org/2000/svg';
    const size = radius * 2;
    const svg = document.createElementNS(svgNS, 'svg');
    svg.setAttribute('width', size);
    svg.setAttribute('height', size);
    svg.setAttribute('viewBox', `0 0 ${size} ${size}`);
    svg.classList.add('cell');

    const poly = document.createElementNS(svgNS, 'polygon');
    const pad = 2;
    const r = radius - pad;
    const pts = [];
    for (let i = 0; i < 6; i++) {
      const angle = (Math.PI / 3) * i - Math.PI / 6; // flat-top
      pts.push(`${radius + r * Math.cos(angle)},${radius + r * Math.sin(angle)}`);
    }
    poly.setAttribute('points', pts.join(' '));
    svg.appendChild(poly);

    const txt = document.createElementNS(svgNS, 'text');
    txt.setAttribute('x', radius);
    txt.setAttribute('y', radius);
    txt.setAttribute('text-anchor', 'middle');
    txt.setAttribute('dominant-baseline', 'central');
    txt.setAttribute('font-size', Math.max(10, radius * 0.55) + 'px');
    txt.textContent = num;
    svg.appendChild(txt);

    return svg;
  }

  /* ‚îÄ‚îÄ Organic layout generators ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ */
  function generateTriLayout(count) {
    const maxCols = 12;
    const maxRows = 8;
    const startR = Math.floor(maxRows / 2);
    const startC = Math.floor(maxCols / 2);

    const positions = [];
    const used = new Set();
    const key = (r, c) => `${r},${c}`;
    const frontier = [[startR, startC]];
    used.add(key(startR, startC));
    positions.push([startR, startC]);

    while (positions.length < count && frontier.length > 0) {
      const idx = Math.floor(Math.random() * frontier.length);
      const [r, c] = frontier[idx];
      const neighbors = [
        [r, c - 1], [r, c + 1], [r - 1, c], [r + 1, c]
      ].filter(([nr, nc]) =>
        nr >= 0 && nr < maxRows && nc >= 0 && nc < maxCols && !used.has(key(nr, nc))
      );

      if (neighbors.length === 0) { frontier.splice(idx, 1); continue; }

      const [nr, nc] = neighbors[Math.floor(Math.random() * neighbors.length)];
      used.add(key(nr, nc));
      positions.push([nr, nc]);
      frontier.push([nr, nc]);
    }

    const minR = Math.min(...positions.map(p => p[0]));
    const minC = Math.min(...positions.map(p => p[1]));
    return positions.map(([r, c]) => [r - minR, c - minC]);
  }

  function generateHexLayout(count) {
    const maxCols = 10;
    const maxRows = 8;
    const startR = Math.floor(maxRows / 2);
    const startC = Math.floor(maxCols / 2);

    const positions = [];
    const used = new Set();
    const key = (r, c) => `${r},${c}`;
    const frontier = [[startR, startC]];
    used.add(key(startR, startC));
    positions.push([startR, startC]);

    while (positions.length < count && frontier.length > 0) {
      const idx = Math.floor(Math.random() * frontier.length);
      const [r, c] = frontier[idx];

      // Hex neighbors (offset coords, even-r)
      const isEven = r % 2 === 0;
      const neighbors = isEven
        ? [[r-1,c-1],[r-1,c],[r,c-1],[r,c+1],[r+1,c-1],[r+1,c]]
        : [[r-1,c],[r-1,c+1],[r,c-1],[r,c+1],[r+1,c],[r+1,c+1]];

      const valid = neighbors.filter(([nr, nc]) =>
        nr >= 0 && nr < maxRows && nc >= 0 && nc < maxCols && !used.has(key(nr, nc))
      );

      if (valid.length === 0) { frontier.splice(idx, 1); continue; }

      const [nr, nc] = valid[Math.floor(Math.random() * valid.length)];
      used.add(key(nr, nc));
      positions.push([nr, nc]);
      frontier.push([nr, nc]);
    }

    const minR = Math.min(...positions.map(p => p[0]));
    const minC = Math.min(...positions.map(p => p[1]));
    return positions.map(([r, c]) => [r - minR, c - minC]);
  }

  /* ‚îÄ‚îÄ Board generation ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ */
  function buildBoard() {
    const cfg = DIFFICULTIES[difficulty];
    const { numRange } = cfg;
    const count = cellCount;

    const vp = window.visualViewport;
    const vpW = vp ? vp.width : window.innerWidth;
    const vpH = vp ? vp.height : window.innerHeight;
    const paddingX = 16;
    const availW = vpW - paddingX;
    const availH = vpH - 180;

    gameContainer.innerHTML = '';
    cells = [];
    totalDiv3 = 0;
    foundCount = 0;
    chainCount = 0;
    bestStreak = 0;
    score = 0;
    streak = 0;

    // Generate numbers
    const pool = new Set();
    while (pool.size < count) {
      pool.add(Math.floor(Math.random() * (numRange[1] - numRange[0] + 1)) + numRange[0]);
    }
    const nums = [...pool];

    // Ensure at least 25% are divisible by 3
    const minDiv3 = Math.ceil(count * 0.25);
    let div3Count = nums.filter(n => n % 3 === 0).length;
    let idx = 0;
    while (div3Count < minDiv3 && idx < nums.length) {
      if (nums[idx] % 3 !== 0) {
        let replacement;
        do { replacement = (Math.floor(Math.random() * 11) + 1) * 3; }
        while (nums.includes(replacement));
        nums[idx] = replacement;
        div3Count++;
      }
      idx++;
    }

    // Shuffle
    for (let i = nums.length - 1; i > 0; i--) {
      const j = Math.floor(Math.random() * (i + 1));
      [nums[i], nums[j]] = [nums[j], nums[i]];
    }

    let boardW, boardH;

    if (tileShape === 'hex') {
      const positions = generateHexLayout(count);
      const maxCol = Math.max(...positions.map(p => p[1]));
      const maxRow = Math.max(...positions.map(p => p[0]));

      // Compute hex radius from available space
      const cols = maxCol + 1;
      const rows = maxRow + 1;
      const idealFromW = Math.floor(availW / (cols * 3 + 0.5)) * 2;
      const idealFromH = Math.floor(availH / (rows * 0.88 + 0.5));
      let hexR = Math.min(40, Math.max(22, Math.min(idealFromW, idealFromH) / 2));
      hexR = Math.round(hexR);

      const hexW = hexR * 2;
      const hexH = Math.round(hexR * Math.sqrt(3));
      TILE_W = hexW;
      TILE_H = hexW; // hex SVG is square (2r x 2r)

      boardW = (maxCol + 1) * hexR * 3 + hexR * 2 + 10;
      boardH = (maxRow + 1) * hexH * 0.88 + hexH + 10;
      gameContainer.style.width = boardW + 'px';
      gameContainer.style.height = boardH + 'px';

      positions.forEach(([r, c], i) => {
        const num = nums[i];
        const div3 = num % 3 === 0;
        if (div3) totalDiv3++;

        const el = makeHexSvg(num, hexR);

        const offset = (r % 2 === 1) ? hexR * 1.5 : 0;
        const x = c * hexR * 3 + offset;
        const y = r * hexH * 0.88;
        el.style.left = x + 'px';
        el.style.top = y + 'px';

        const cell = { num, div3, el, row: r, col: c, picked: false, pairable: false, cx: x + hexR, cy: y + hexR };
        el._cell = cell;
        el.querySelector('polygon')._cell = cell;
        cells.push(cell);
        gameContainer.appendChild(el);
      });

    } else {
      // Triangle mode
      const positions = generateTriLayout(count);
      const maxCol = Math.max(...positions.map(p => p[1]));
      const maxRow = Math.max(...positions.map(p => p[0]));
      const cols = maxCol + 1;
      const rows = maxRow + 1;

      const idealW = Math.floor(availW / (cols / 2 + 0.5));
      const idealFromH = Math.round((availH / rows) * 64 / 56);
      TILE_W = Math.min(90, Math.max(44, Math.min(idealW, idealFromH)));
      TILE_H = Math.round(TILE_W * 56 / 64);

      boardW = (cols * TILE_W / 2) + TILE_W / 2;
      boardH = rows * TILE_H + 10;
      gameContainer.style.width = boardW + 'px';
      gameContainer.style.height = boardH + 'px';

      positions.forEach(([r, c], i) => {
        const pointsUp = (r + c) % 2 === 0;
        const num = nums[i];
        const div3 = num % 3 === 0;
        if (div3) totalDiv3++;

        const el = makeTriSvg(num, pointsUp);

        const x = c * (TILE_W / 2);
        const y = r * TILE_H;
        el.style.left = x + 'px';
        el.style.top = y + 'px';

        const cell = { num, div3, el, row: r, col: c, picked: false, pairable: false, cx: x + TILE_W / 2, cy: y + TILE_H / 2 };
        el._cell = cell;
        el.querySelector('polygon')._cell = cell;
        cells.push(cell);
        gameContainer.appendChild(el);
      });
    }

    // Create SVG overlay for drag lines
    const svgNS = 'http://www.w3.org/2000/svg';
    dragOverlaySvg = document.createElementNS(svgNS, 'svg');
    dragOverlaySvg.classList.add('drag-overlay');
    dragOverlaySvg.setAttribute('width', boardW);
    dragOverlaySvg.setAttribute('height', boardH);
    gameContainer.appendChild(dragOverlaySvg);

    // Create sum indicator
    sumIndicator = document.createElement('div');
    sumIndicator.className = 'chain-sum-indicator';
    sumIndicator.style.display = 'none';
    gameContainer.appendChild(sumIndicator);

    markPairableCells();
    updateHUD();
  }

  /* ‚îÄ‚îÄ Pairable detection ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ */
  function markPairableCells() {
    const nonDiv3 = cells.filter(c => !c.div3 && !c.picked);
    for (const cell of nonDiv3) cell.pairable = false;
    for (let i = 0; i < nonDiv3.length; i++) {
      for (let j = i + 1; j < nonDiv3.length; j++) {
        if ((nonDiv3[i].num + nonDiv3[j].num) % 3 === 0) {
          nonDiv3[i].pairable = true;
          nonDiv3[j].pairable = true;
        }
        for (let k = j + 1; k < nonDiv3.length; k++) {
          if ((nonDiv3[i].num + nonDiv3[j].num + nonDiv3[k].num) % 3 === 0) {
            nonDiv3[i].pairable = true;
            nonDiv3[j].pairable = true;
            nonDiv3[k].pairable = true;
          }
          for (let l = k + 1; l < nonDiv3.length; l++) {
            if ((nonDiv3[i].num + nonDiv3[j].num + nonDiv3[k].num + nonDiv3[l].num) % 3 === 0) {
              nonDiv3[i].pairable = true;
              nonDiv3[j].pairable = true;
              nonDiv3[k].pairable = true;
              nonDiv3[l].pairable = true;
            }
          }
        }
      }
    }
  }

  /* ‚îÄ‚îÄ Cell center helper ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ */
  function getCellCenter(cell) {
    return { x: cell.cx, y: cell.cy };
  }

  /* ‚îÄ‚îÄ Floating feedback text ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ */
  function showFloat(cell, text, color) {
    const el = document.createElement('div');
    el.className = 'float-text';
    el.style.color = color;
    el.textContent = text;
    const ctr = getCellCenter(cell);
    el.style.left = ctr.x + 'px';
    el.style.top = (ctr.y - 20) + 'px';
    el.style.transform = 'translateX(-50%)';
    gameContainer.appendChild(el);
    setTimeout(() => el.remove(), 800);
  }

  /* ‚îÄ‚îÄ Cell click handler (for taps) ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ */
  function onCellClick(cell) {
    if (!gameActive || cell.picked) return;

    if (cell.div3) {
      cell.picked = true;
      cell.el.classList.add('disabled');
      cell.el.classList.add('correct');
      foundCount++;
      streak++;
      if (streak > bestStreak) bestStreak = streak;
      let pts = 100;
      if (streak >= BONUS_STREAK) pts += 50 * (streak - BONUS_STREAK + 1);
      pts += Math.round(timeLeft * 10);
      score += pts;
      showFloat(cell, `+${pts} üçØ`, 'var(--correct)');

      if (foundCount === totalDiv3) {
        endGame(true);
        return;
      }
    } else if (cell.pairable) {
      return;
    } else {
      cell.picked = true;
      cell.el.classList.add('disabled');
      cell.el.classList.add('wrong');
      streak = 0;
      score = Math.max(0, score - 50);
      showFloat(cell, '‚ö° Sting! -50', 'var(--wrong)');
    }

    updateHUD();
  }

  /* ‚îÄ‚îÄ Drag chain logic ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ */
  function cellFromPoint(x, y) {
    if (dragOverlaySvg) dragOverlaySvg.style.display = 'none';
    if (sumIndicator) sumIndicator.style.display = 'none';
    const el = document.elementFromPoint(x, y);
    if (dragOverlaySvg) dragOverlaySvg.style.display = '';
    if (sumIndicator && dragActive) sumIndicator.style.display = '';
    if (!el) return null;
    if (el._cell) return el._cell;
    if (el.parentElement && el.parentElement._cell) return el.parentElement._cell;
    return null;
  }

  function updateDragPolyline() {
    if (!dragPolyline || dragChain.length === 0) return;
    const points = dragChain.map(c => {
      const ctr = getCellCenter(c);
      return `${ctr.x},${ctr.y}`;
    });
    const rect = gameContainer.getBoundingClientRect();
    const cx = cursorX - rect.left;
    const cy = cursorY - rect.top;
    points.push(`${cx},${cy}`);
    dragPolyline.setAttribute('points', points.join(' '));
  }

  function updateSumIndicator() {
    if (!sumIndicator || dragChain.length === 0) return;
    const sum = dragChain.reduce((s, c) => s + c.num, 0);
    const rect = gameContainer.getBoundingClientRect();
    sumIndicator.textContent = `Sum: ${sum}${dragChain.length >= 2 ? (sum % 3 === 0 ? ' \u2713' : '') : ''}`;
    sumIndicator.className = 'chain-sum-indicator';
    if (dragChain.length >= 2) {
      sumIndicator.classList.add(sum % 3 === 0 ? 'valid' : 'invalid');
    }
    sumIndicator.style.left = (cursorX - rect.left + 15) + 'px';
    sumIndicator.style.top = (cursorY - rect.top - 25) + 'px';
    sumIndicator.style.display = '';
  }

  function startDrag(cell, e) {
    dragActive = true;
    dragChain = [cell];
    dragPointerId = e.pointerId;
    dragStartX = e.clientX;
    dragStartY = e.clientY;
    dragStartTime = Date.now();
    dragStartCell = cell;
    cursorX = e.clientX;
    cursorY = e.clientY;
    lastHoveredCell = cell;

    cell.el.classList.add('drag-source');

    const svgNS = 'http://www.w3.org/2000/svg';
    dragPolyline = document.createElementNS(svgNS, 'polyline');
    dragOverlaySvg.appendChild(dragPolyline);
    updateDragPolyline();
    sumIndicator.style.display = '';
    updateSumIndicator();
  }

  function addToChain(cell) {
    if (dragChain.includes(cell)) return;
    if (dragChain.length >= 4) return;
    if (cell.picked || cell.div3) return;

    dragChain.push(cell);
    cell.el.classList.add('chain-member');
    updateDragPolyline();
    updateSumIndicator();
  }

  function removeLastFromChain() {
    if (dragChain.length <= 1) return;
    const removed = dragChain.pop();
    removed.el.classList.remove('chain-member');
    updateDragPolyline();
    updateSumIndicator();
  }

  function endDrag() {
    if (!dragActive) return;
    dragActive = false;

    const sum = dragChain.reduce((s, c) => s + c.num, 0);
    const isValid = dragChain.length >= 2 && sum % 3 === 0;

    if (isValid) {
      const chainSize = dragChain.length;
      let pts = CHAIN_POINTS[chainSize] || 150;
      streak++;
      if (streak > bestStreak) bestStreak = streak;
      if (streak >= BONUS_STREAK) pts += 50 * (streak - BONUS_STREAK + 1);
      pts += Math.round(timeLeft * 10);
      score += pts;
      chainCount++;

      const label = chainSize === 2 ? 'Pair' : chainSize === 3 ? 'Swarm x3' : 'Swarm x4!';
      showFloat(dragChain[0], `üêù ${label} +${pts} üçØ`, 'var(--connected)');

      dragChain.forEach(c => {
        c.picked = true;
        c.el.classList.remove('drag-source', 'chain-member');
        c.el.classList.add('connected', 'disabled');
      });

      if (dragPolyline) {
        const points = dragChain.map(c => {
          const ctr = getCellCenter(c);
          return `${ctr.x},${ctr.y}`;
        });
        dragPolyline.setAttribute('points', points.join(' '));
        dragPolyline.classList.add('chain-success');
        dragPolyline = null;
      }

      markPairableCells();
    } else if (dragChain.length >= 2) {
      streak = 0;
      score = Math.max(0, score - 50);
      showFloat(dragChain[0], '‚ö° Bad swarm! -50', 'var(--wrong)');

      dragChain.forEach(c => {
        c.el.classList.remove('drag-source', 'chain-member');
        c.el.classList.add('wrong');
        setTimeout(() => c.el.classList.remove('wrong'), 400);
      });

      if (dragPolyline) { dragPolyline.remove(); dragPolyline = null; }
    } else {
      dragChain.forEach(c => c.el.classList.remove('drag-source', 'chain-member'));
      if (dragPolyline) { dragPolyline.remove(); dragPolyline = null; }
    }

    if (sumIndicator) sumIndicator.style.display = 'none';
    dragChain = [];
    dragStartCell = null;
    lastHoveredCell = null;
    updateHUD();
  }

  /* ‚îÄ‚îÄ Pointer event handlers ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ */
  gameContainer.addEventListener('pointerdown', (e) => {
    if (!gameActive) return;
    const cell = cellFromPoint(e.clientX, e.clientY);
    if (!cell || cell.picked) return;

    e.preventDefault();
    gameContainer.setPointerCapture(e.pointerId);

    if (cell.div3) {
      dragStartX = e.clientX;
      dragStartY = e.clientY;
      dragStartTime = Date.now();
      dragStartCell = cell;
      dragPointerId = e.pointerId;
      dragActive = false;
    } else {
      startDrag(cell, e);
    }
  });

  gameContainer.addEventListener('pointermove', (e) => {
    if (!gameActive) return;
    if (dragPointerId !== e.pointerId) return;

    cursorX = e.clientX;
    cursorY = e.clientY;

    if (!dragActive && dragStartCell && dragStartCell.div3) return;
    if (!dragActive) return;

    updateDragPolyline();
    updateSumIndicator();

    gameContainer.releasePointerCapture(e.pointerId);
    const cell = cellFromPoint(e.clientX, e.clientY);
    gameContainer.setPointerCapture(e.pointerId);

    if (!cell || cell.picked || cell.div3) { lastHoveredCell = null; return; }
    if (cell === lastHoveredCell) return;
    lastHoveredCell = cell;

    if (dragChain.length >= 2 && cell === dragChain[dragChain.length - 2]) {
      removeLastFromChain();
      return;
    }

    if (!dragChain.includes(cell)) addToChain(cell);
  });

  gameContainer.addEventListener('pointerup', (e) => {
    if (!gameActive) return;
    if (dragPointerId !== e.pointerId) return;

    try { gameContainer.releasePointerCapture(e.pointerId); } catch {}

    const dx = e.clientX - dragStartX;
    const dy = e.clientY - dragStartY;
    const dist = Math.sqrt(dx * dx + dy * dy);
    const duration = Date.now() - dragStartTime;

    if (dragStartCell && dragStartCell.div3 && !dragActive) {
      if (dist < 10 && duration < 300) onCellClick(dragStartCell);
      dragStartCell = null;
      dragPointerId = null;
      return;
    }

    if (dragActive && dragChain.length === 1 && dist < 10 && duration < 300) {
      const cell = dragChain[0];
      cell.el.classList.remove('drag-source');
      if (dragPolyline) { dragPolyline.remove(); dragPolyline = null; }
      if (sumIndicator) sumIndicator.style.display = 'none';
      dragActive = false;
      dragChain = [];

      if (!cell.pairable) onCellClick(cell);
      dragStartCell = null;
      dragPointerId = null;
      return;
    }

    endDrag();
    dragPointerId = null;
  });

  gameContainer.addEventListener('pointercancel', (e) => {
    if (dragPointerId === e.pointerId) {
      endDrag();
      dragPointerId = null;
    }
  });

  /* ‚îÄ‚îÄ HUD ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ */
  function updateHUD() {
    foundDisp.textContent = `${foundCount} / ${totalDiv3}`;
    chainsDisp.textContent = chainCount;
    scoreDisp.textContent = score;

    if (streak >= BONUS_STREAK) {
      buzzBadge.textContent = `üêù x${streak} Buzz!`;
      buzzBadge.classList.add('active');
    } else {
      buzzBadge.classList.remove('active');
    }
  }

  /* ‚îÄ‚îÄ Timer ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ */
  function startTimer() {
    const cfg = DIFFICULTIES[difficulty];
    timeLeft = cfg.time;
    timerDisp.textContent = timeLeft.toFixed(1);

    timerInterval = setInterval(() => {
      timeLeft -= 0.1;
      if (timeLeft <= 0) {
        timeLeft = 0;
        timerDisp.textContent = '0.0';
        endGame(false);
        return;
      }
      timerDisp.textContent = timeLeft.toFixed(1);
      if (timeLeft <= 3) timerDisp.style.color = 'var(--wrong)';
      else timerDisp.style.color = '';
    }, 100);
  }

  /* ‚îÄ‚îÄ Countdown ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ */
  function doCountdown(cb) {
    let count = 3;
    countdownOverlay.classList.add('active');
    countdownNumber.textContent = count;

    const tick = () => {
      count--;
      if (count === 0) {
        countdownNumber.textContent = 'üêù GO!';
        setTimeout(() => { countdownOverlay.classList.remove('active'); cb(); }, 400);
      } else {
        countdownNumber.textContent = count;
        countdownNumber.style.animation = 'none';
        void countdownNumber.offsetHeight;
        countdownNumber.style.animation = '';
        setTimeout(tick, 600);
      }
    };
    setTimeout(tick, 600);
  }

  /* ‚îÄ‚îÄ Game lifecycle ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ */
  function startGame() {
    menuScreen.classList.remove('active');
    resultScreen.classList.remove('active');
    document.body.classList.add('game-active');

    buildBoard();
    hud.style.display = 'flex';
    gameContainer.style.display = 'block';

    gameActive = false;
    doCountdown(() => {
      gameActive = true;
      startTimer();
    });
  }

  function endGame(allFound) {
    gameActive = false;
    clearInterval(timerInterval);

    if (dragActive) {
      dragChain.forEach(c => c.el.classList.remove('drag-source', 'chain-member'));
      if (dragPolyline) { dragPolyline.remove(); dragPolyline = null; }
      if (sumIndicator) sumIndicator.style.display = 'none';
      dragActive = false;
      dragChain = [];
      dragPointerId = null;
    }

    cells.forEach(c => {
      if (c.div3 && !c.picked) c.el.classList.add('reveal');
      c.el.classList.add('disabled');
    });

    if (allFound) {
      score += Math.round(timeLeft * 100);
    }
    updateHUD();
    saveScore(difficulty, score);

    setTimeout(() => {
      document.body.classList.remove('game-active');
      hud.style.display = 'none';
      gameContainer.style.display = 'none';

      const pct = totalDiv3 > 0 ? Math.round((foundCount / totalDiv3) * 100) : 0;
      let title;
      if (allFound) title = 'üëë QUEEN BEE!';
      else if (pct >= 75) title = 'üêù GREAT BUZZ!';
      else if (pct >= 50) title = 'üçØ NOT BAD!';
      else title = 'üòµ STUNG OUT!';

      $('result-title').textContent = title;
      $('result-title').style.color = allFound ? 'var(--correct)' : (pct >= 50 ? 'var(--accent)' : 'var(--wrong)');

      $('result-stats').innerHTML = `
        Pollinated <span>${foundCount}</span> of <span>${totalDiv3}</span> flowers üå∏<br>
        ${chainCount > 0 ? `Swarms: <span style="color:var(--connected)">${chainCount}</span> üîó<br>` : ''}
        ${bestStreak >= BONUS_STREAK ? `Best Buzz: <span style="color:var(--accent)">üêù x${bestStreak}</span><br>` : ''}
        Honey: <span style="color:var(--correct)">${score} üçØ</span><br>
        Difficulty: <span>${difficulty}</span>
        ${allFound ? `<br>Time bonus: <span style="color:var(--accent)">+${Math.round(timeLeft * 100)} üçØ</span>` : ''}
      `;

      renderScores($('result-scores'), difficulty);
      resultScreen.classList.add('active');
    }, 1200);
  }

  /* ‚îÄ‚îÄ Button wiring ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ */
  $('start-btn').addEventListener('click', startGame);
  $('replay-btn').addEventListener('click', startGame);
  $('menu-btn').addEventListener('click', () => {
    resultScreen.classList.remove('active');
    hud.style.display = 'none';
    gameContainer.style.display = 'none';
    renderScores($('menu-scores'), difficulty);
    menuScreen.classList.add('active');
  });

  /* ‚îÄ‚îÄ Init ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ */
  renderScores($('menu-scores'), difficulty);
  diffBtns.forEach(btn => {
    btn.addEventListener('click', () => renderScores($('menu-scores'), btn.dataset.diff));
  });

})();
</script>
</body>
</html>
